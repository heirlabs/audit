#pragma version >=0.4.0;
#include "stdlib.fc";

;; ===============================================
;; DeFAI Swap Contract for TON Blockchain
;; Transpiled from Solana implementation
;; ===============================================

;; Constants
const int INITIAL_TAX_BPS = 500;        ;; 5%
const int TAX_INCREMENT_BPS = 100;      ;; 1% each swap
const int TAX_CAP_BPS = 3000;          ;; 30% maximum tax
const int TAX_RESET_DURATION = 86400;   ;; 24 hours in seconds
const int ADMIN_TIMELOCK_DURATION = 172800; ;; 48 hours
const int VESTING_DURATION = 7776000;   ;; 90 days in seconds
const int CLIFF_DURATION = 172800;      ;; 2 days in seconds

;; Tier bonus ranges (basis points)
const int TIER_0_MIN_BONUS = 0;
const int TIER_0_MAX_BONUS = 0;
const int TIER_1_MIN_BONUS = 0;
const int TIER_1_MAX_BONUS = 1500;
const int TIER_2_MIN_BONUS = 1500;
const int TIER_2_MAX_BONUS = 5000;
const int TIER_3_MIN_BONUS = 2000;
const int TIER_3_MAX_BONUS = 10000;
const int TIER_4_MIN_BONUS = 5000;
const int TIER_4_MAX_BONUS = 30000;

;; Operation codes
const int op::initialize = 0x7e8764ef;
const int op::update_prices = 0x4f89dc2a;
const int op::update_treasury = 0x8c3f5d21;
const int op::pause = 0x2c5f4ab1;
const int op::unpause = 0x9d4f2c8e;
const int op::propose_admin = 0x5a8b3c71;
const int op::accept_admin = 0x7f2e9d4a;
const int op::initialize_user_tax = 0x3b8c7f2d;
const int op::reset_user_tax = 0x6d4a8f3e;
const int op::swap_defai_for_nft = 0x8e7c3f5a;
const int op::swap_old_defai_for_nft = 0x2f8d6c4b;
const int op::swap_og_tier0 = 0x9c3e7a8f;
const int op::redeem = 0x4e8c7d2f;
const int op::claim_vested = 0x7a3f8c5d;
const int op::claim_airdrop = 0x5c7d9e3f;
const int op::claim_vested_airdrop = 0x8f3c7e5a;
const int op::reroll_bonus = 0x3d7c8f2e;
const int op::admin_withdraw = 0x6f8c3a7e;
const int op::initialize_randomness = 0x8c5f3e7d;
const int op::commit_randomness = 0x7e3c8f5a;
const int op::reveal_randomness = 0x9f7c3e8d;

;; Error codes
const int error::insufficient_old_tokens = 101;
const int error::insufficient_defai_tokens = 102;
const int error::no_liquidity = 103;
const int error::invalid_collection = 104;
const int error::math_overflow = 105;
const int error::nft_already_redeemed = 106;
const int error::no_nft = 107;
const int error::invalid_input = 108;
const int error::invalid_treasury = 109;
const int error::unauthorized = 110;
const int error::invalid_tier = 111;
const int error::already_claimed = 112;
const int error::invalid_merkle_proof = 113;
const int error::still_in_cliff = 114;
const int error::nothing_to_claim = 115;
const int error::tax_reset_too_early = 116;
const int error::already_paused = 117;
const int error::not_paused = 118;
const int error::protocol_paused = 119;
const int error::invalid_mint = 120;
const int error::insufficient_defai_for_reroll = 121;
const int error::no_pending_admin = 122;
const int error::timelock_not_expired = 123;
const int error::not_on_og_whitelist = 124;
const int error::og_tier0_already_claimed = 125;
const int error::invalid_nft = 126;
const int error::randomness_not_ready = 127;

;; ===============================================
;; Storage Layout
;; ===============================================

;; Storage structure:
;; config#_ admin:MsgAddress old_mint:MsgAddress new_mint:MsgAddress 
;;          collection:MsgAddress treasury:MsgAddress prices:^Cell 
;;          paused:Bool pending_admin:(Maybe MsgAddress) 
;;          admin_change_timestamp:uint64 vrf_enabled:Bool = Config;

;; tier_prices#_ price0:Coins price1:Coins price2:Coins price3:Coins price4:Coins = TierPrices;

;; tier_supplies#_ supply0:uint16 supply1:uint16 supply2:uint16 supply3:uint16 supply4:uint16 = TierSupplies;

;; tier_minted#_ minted0:uint16 minted1:uint16 minted2:uint16 minted3:uint16 minted4:uint16 = TierMinted;

;; collection_config#_ authority:MsgAddress collection_mint:MsgAddress 
;;                     treasury:MsgAddress defai_mint:MsgAddress 
;;                     old_defai_mint:MsgAddress tier_data:^Cell 
;;                     merkle_roots:^Cell og_supply:uint16 og_minted:uint16 = CollectionConfig;

;; user_tax_state#_ user:MsgAddress tax_rate_bps:uint16 
;;                  last_swap_timestamp:uint64 swap_count:uint32 = UserTaxState;

;; bonus_state#_ mint:MsgAddress tier:uint8 bonus_bps:uint16 
;;               vesting_start:uint64 vesting_duration:uint64 
;;               claimed:Bool fee_deducted:Coins = BonusState;

;; vesting_state#_ mint:MsgAddress total_amount:Coins released_amount:Coins 
;;                 start_timestamp:uint64 end_timestamp:uint64 
;;                 last_claimed_timestamp:uint64 = VestingState;

;; randomness_state#_ authority:MsgAddress randomness_value:uint256 
;;                    last_update:uint64 is_pending:Bool = RandomnessState;

;; ===============================================
;; Storage Management
;; ===============================================

() save_data(cell config, cell collection_config, cell tax_states, 
             cell bonus_states, cell vesting_states, cell randomness_state) impure {
    set_data(begin_cell()
        .store_ref(config)
        .store_ref(collection_config)
        .store_ref(tax_states)
        .store_ref(bonus_states)
        .store_ref(vesting_states)
        .store_ref(randomness_state)
        .end_cell());
}

(cell, cell, cell, cell, cell, cell) load_data() {
    slice ds = get_data().begin_parse();
    return (ds~load_ref(), ds~load_ref(), ds~load_ref(), 
            ds~load_ref(), ds~load_ref(), ds~load_ref());
}

;; ===============================================
;; Helper Functions
;; ===============================================

(int, int) get_tier_bonus_range(int tier) {
    if (tier == 0) { return (TIER_0_MIN_BONUS, TIER_0_MAX_BONUS); }
    if (tier == 1) { return (TIER_1_MIN_BONUS, TIER_1_MAX_BONUS); }
    if (tier == 2) { return (TIER_2_MIN_BONUS, TIER_2_MAX_BONUS); }
    if (tier == 3) { return (TIER_3_MIN_BONUS, TIER_3_MAX_BONUS); }
    if (tier == 4) { return (TIER_4_MIN_BONUS, TIER_4_MAX_BONUS); }
    return (0, 0);
}

int calculate_random_bonus(int random_value, int min_bonus, int max_bonus) {
    int bonus_range = max_bonus - min_bonus;
    if (bonus_range == 0) {
        return min_bonus;
    }
    return min_bonus + (random_value % (bonus_range + 1));
}

int generate_random(slice user, slice nft_mint, int timestamp) {
    ;; Simple pseudo-random generation using hash
    ;; In production, use proper VRF or oracle
    cell random_data = begin_cell()
        .store_slice(user)
        .store_slice(nft_mint)
        .store_uint(timestamp, 64)
        .store_uint(now(), 32)
        .end_cell();
    
    return string_hash(random_data.begin_parse()) % 0xFFFFFFFF;
}

int calculate_tax(int amount, int tax_rate_bps) {
    return (amount * tax_rate_bps) / 10000;
}

int calculate_vested_amount(int total_amount, int start_timestamp, 
                           int end_timestamp, int current_time) {
    if (current_time >= end_timestamp) {
        return total_amount;
    }
    
    int elapsed = current_time - start_timestamp;
    int duration = end_timestamp - start_timestamp;
    
    if (duration == 0) {
        return 0;
    }
    
    return (total_amount * elapsed) / duration;
}

;; ===============================================
;; Merkle Tree Verification
;; ===============================================

int verify_merkle_proof(slice leaf, cell proof, int root) {
    int current_hash = string_hash(leaf);
    
    while (~ proof.slice_empty?()) {
        slice proof_elem = proof~load_ref().begin_parse();
        int proof_hash = proof_elem~load_uint(256);
        
        if (current_hash <= proof_hash) {
            current_hash = string_hash(begin_cell()
                .store_uint(current_hash, 256)
                .store_uint(proof_hash, 256)
                .end_cell().begin_parse());
        } else {
            current_hash = string_hash(begin_cell()
                .store_uint(proof_hash, 256)
                .store_uint(current_hash, 256)
                .end_cell().begin_parse());
        }
    }
    
    return current_hash == root;
}

;; ===============================================
;; Internal Message Handlers
;; ===============================================

() handle_initialize(slice in_msg_body, slice sender_address) impure {
    ;; Parse initialization parameters
    slice old_mint = in_msg_body~load_msg_addr();
    slice new_mint = in_msg_body~load_msg_addr();
    slice collection = in_msg_body~load_msg_addr();
    slice treasury = in_msg_body~load_msg_addr();
    
    ;; Load tier prices
    cell prices = in_msg_body~load_ref();
    
    ;; Create initial config
    cell config = begin_cell()
        .store_slice(sender_address)  ;; admin
        .store_slice(old_mint)
        .store_slice(new_mint)
        .store_slice(collection)
        .store_slice(treasury)
        .store_ref(prices)
        .store_uint(0, 1)  ;; not paused
        .store_uint(0, 1)  ;; no pending admin
        .store_uint(0, 64) ;; admin change timestamp
        .store_uint(1, 1)  ;; VRF enabled by default
        .end_cell();
    
    ;; Initialize collection config
    cell collection_config = begin_cell()
        .store_slice(sender_address)  ;; authority
        .store_slice(collection)       ;; collection_mint
        .store_slice(treasury)
        .store_slice(new_mint)         ;; defai_mint
        .store_slice(old_mint)         ;; old_defai_mint
        .store_ref(begin_cell().end_cell())  ;; tier_data (empty initially)
        .store_ref(begin_cell().end_cell())  ;; merkle_roots (empty initially)
        .store_uint(0, 16)  ;; og_supply
        .store_uint(0, 16)  ;; og_minted
        .end_cell();
    
    ;; Initialize empty state dictionaries
    cell tax_states = new_dict();
    cell bonus_states = new_dict();
    cell vesting_states = new_dict();
    
    ;; Initialize randomness state
    cell randomness_state = begin_cell()
        .store_slice(sender_address)
        .store_uint(0, 256)  ;; random value
        .store_uint(now(), 64)  ;; last update
        .store_uint(0, 1)  ;; not pending
        .end_cell();
    
    save_data(config, collection_config, tax_states, 
              bonus_states, vesting_states, randomness_state);
}

() handle_swap_defai_for_nft(slice in_msg_body, slice sender_address) impure {
    ;; Load contract state
    (cell config_cell, cell collection_config, cell tax_states, 
     cell bonus_states, cell vesting_states, cell randomness_state) = load_data();
    
    slice config = config_cell.begin_parse();
    slice admin = config~load_msg_addr();
    config~skip_bits(267 * 2);  ;; Skip old_mint, new_mint, collection
    slice treasury = config~load_msg_addr();
    cell prices_cell = config~load_ref();
    int paused = config~load_uint(1);
    
    ;; Check if protocol is paused
    throw_if(error::protocol_paused, paused);
    
    ;; Parse swap parameters
    int tier = in_msg_body~load_uint(8);
    throw_if(error::invalid_tier, tier >= 5);
    
    ;; Load tier prices
    slice prices = prices_cell.begin_parse();
    int price = 0;
    repeat(tier + 1) {
        price = prices~load_coins();
    }
    
    ;; Load or create user tax state
    int user_hash = slice_hash(sender_address);
    (slice user_tax_data, int found) = tax_states.udict_get?(256, user_hash);
    
    int tax_rate_bps = INITIAL_TAX_BPS;
    int last_swap_timestamp = 0;
    int swap_count = 0;
    
    if (found) {
        user_tax_data~skip_bits(267);  ;; Skip user address
        tax_rate_bps = user_tax_data~load_uint(16);
        last_swap_timestamp = user_tax_data~load_uint(64);
        swap_count = user_tax_data~load_uint(32);
        
        ;; Reset tax if 24 hours passed
        if (now() - last_swap_timestamp >= TAX_RESET_DURATION) {
            tax_rate_bps = INITIAL_TAX_BPS;
            swap_count = 0;
        }
    }
    
    ;; Calculate tax and net amounts
    int tax_amount = calculate_tax(price, tax_rate_bps);
    int net_amount = price - tax_amount;
    
    ;; Generate random bonus
    (int min_bonus, int max_bonus) = get_tier_bonus_range(tier);
    int random_value = generate_random(sender_address, sender_address, now());
    int bonus_bps = calculate_random_bonus(random_value, min_bonus, max_bonus);
    
    ;; Calculate vesting amount
    int vesting_amount = (price * bonus_bps) / 10000;
    
    ;; Create NFT mint (simplified - in real implementation would create actual NFT)
    slice nft_mint = sender_address;  ;; Use sender as NFT ID for simplicity
    
    ;; Store bonus state
    cell bonus_data = begin_cell()
        .store_slice(nft_mint)
        .store_uint(tier, 8)
        .store_uint(bonus_bps, 16)
        .store_uint(now(), 64)  ;; vesting_start
        .store_uint(VESTING_DURATION, 64)
        .store_uint(0, 1)  ;; not claimed
        .store_coins(0)    ;; fee_deducted
        .end_cell();
    
    bonus_states~udict_set(256, slice_hash(nft_mint), bonus_data.begin_parse());
    
    ;; Store vesting state
    cell vesting_data = begin_cell()
        .store_slice(nft_mint)
        .store_coins(vesting_amount)
        .store_coins(0)  ;; released_amount
        .store_uint(now(), 64)  ;; start_timestamp
        .store_uint(now() + VESTING_DURATION, 64)  ;; end_timestamp
        .store_uint(now(), 64)  ;; last_claimed_timestamp
        .end_cell();
    
    vesting_states~udict_set(256, slice_hash(nft_mint), vesting_data.begin_parse());
    
    ;; Update user tax state
    tax_rate_bps = min(tax_rate_bps + TAX_INCREMENT_BPS, TAX_CAP_BPS);
    swap_count += 1;
    
    cell new_tax_data = begin_cell()
        .store_slice(sender_address)
        .store_uint(tax_rate_bps, 16)
        .store_uint(now(), 64)
        .store_uint(swap_count, 32)
        .end_cell();
    
    tax_states~udict_set(256, user_hash, new_tax_data.begin_parse());
    
    ;; Save updated state
    save_data(config_cell, collection_config, tax_states, 
              bonus_states, vesting_states, randomness_state);
    
    ;; Send response with swap details
    var msg = begin_cell()
        .store_uint(0x10, 6)  ;; nobounce
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x73776170, 32)  ;; "swap" response
        .store_uint(tier, 8)
        .store_coins(price)
        .store_coins(tax_amount)
        .store_uint(bonus_bps, 16)
        .end_cell();
    
    send_raw_message(msg, 64);
}

() handle_redeem(slice in_msg_body, slice sender_address) impure {
    ;; Load contract state
    (cell config_cell, cell collection_config, cell tax_states, 
     cell bonus_states, cell vesting_states, cell randomness_state) = load_data();
    
    slice config = config_cell.begin_parse();
    config~skip_bits(267);  ;; Skip admin
    config~skip_bits(267 * 2);  ;; Skip old_mint, new_mint
    config~skip_bits(267 * 2);  ;; Skip collection, treasury
    cell prices_cell = config~load_ref();
    int paused = config~load_uint(1);
    
    ;; Check if protocol is paused
    throw_if(error::protocol_paused, paused);
    
    ;; Parse redeem parameters
    slice nft_mint = in_msg_body~load_msg_addr();
    
    ;; Load bonus state
    int nft_hash = slice_hash(nft_mint);
    (slice bonus_data, int found) = bonus_states.udict_get?(256, nft_hash);
    throw_unless(error::no_nft, found);
    
    bonus_data~skip_bits(267);  ;; Skip mint
    int tier = bonus_data~load_uint(8);
    int bonus_bps = bonus_data~load_uint(16);
    bonus_data~skip_bits(64 * 2);  ;; Skip vesting times
    int claimed = bonus_data~load_uint(1);
    int fee_deducted = bonus_data~load_coins();
    
    ;; Check NFT not already redeemed
    throw_if(error::nft_already_redeemed, claimed);
    
    ;; Load vesting state
    (slice vesting_data, found) = vesting_states.udict_get?(256, nft_hash);
    throw_unless(error::invalid_nft, found);
    
    vesting_data~skip_bits(267);  ;; Skip mint
    int total_vesting = vesting_data~load_coins();
    
    ;; Get base price from tier
    slice prices = prices_cell.begin_parse();
    int base_price = 0;
    repeat(tier + 1) {
        base_price = prices~load_coins();
    }
    
    ;; Calculate amount to transfer
    int amount_to_transfer = max(base_price - fee_deducted, 0);
    
    ;; Mark as claimed
    cell new_bonus_data = begin_cell()
        .store_slice(nft_mint)
        .store_uint(tier, 8)
        .store_uint(bonus_bps, 16)
        .store_uint(now() - VESTING_DURATION, 64)  ;; vesting_start
        .store_uint(VESTING_DURATION, 64)
        .store_uint(1, 1)  ;; claimed = true
        .store_coins(fee_deducted)
        .end_cell();
    
    bonus_states~udict_set(256, nft_hash, new_bonus_data.begin_parse());
    
    ;; Save updated state
    save_data(config_cell, collection_config, tax_states, 
              bonus_states, vesting_states, randomness_state);
    
    ;; Send response
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(sender_address)
        .store_coins(amount_to_transfer)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x72656465656d, 48)  ;; "redeem" response
        .store_coins(amount_to_transfer)
        .store_coins(fee_deducted)
        .end_cell();
    
    send_raw_message(msg, 64);
}

() handle_claim_vested(slice in_msg_body, slice sender_address) impure {
    ;; Load contract state
    (cell config_cell, cell collection_config, cell tax_states, 
     cell bonus_states, cell vesting_states, cell randomness_state) = load_data();
    
    slice config = config_cell.begin_parse();
    config~skip_bits(267 * 5);  ;; Skip addresses
    config~skip_bits(1);  ;; Skip prices ref
    int paused = config~load_uint(1);
    
    ;; Check if protocol is paused
    throw_if(error::protocol_paused, paused);
    
    ;; Parse claim parameters
    slice nft_mint = in_msg_body~load_msg_addr();
    
    ;; Load vesting state
    int nft_hash = slice_hash(nft_mint);
    (slice vesting_data, int found) = vesting_states.udict_get?(256, nft_hash);
    throw_unless(error::invalid_nft, found);
    
    vesting_data~skip_bits(267);  ;; Skip mint
    int total_amount = vesting_data~load_coins();
    int released_amount = vesting_data~load_coins();
    int start_timestamp = vesting_data~load_uint(64);
    int end_timestamp = vesting_data~load_uint(64);
    int last_claimed_timestamp = vesting_data~load_uint(64);
    
    ;; Check cliff period
    int cliff_end = start_timestamp + CLIFF_DURATION;
    throw_if(error::still_in_cliff, now() < cliff_end);
    
    ;; Calculate vested amount
    int vested_amount = calculate_vested_amount(total_amount, start_timestamp, 
                                               end_timestamp, now());
    
    int claimable = vested_amount - released_amount;
    throw_if(error::nothing_to_claim, claimable <= 0);
    
    ;; Update vesting state
    cell new_vesting_data = begin_cell()
        .store_slice(nft_mint)
        .store_coins(total_amount)
        .store_coins(released_amount + claimable)
        .store_uint(start_timestamp, 64)
        .store_uint(end_timestamp, 64)
        .store_uint(now(), 64)
        .end_cell();
    
    vesting_states~udict_set(256, nft_hash, new_vesting_data.begin_parse());
    
    ;; Save updated state
    save_data(config_cell, collection_config, tax_states, 
              bonus_states, vesting_states, randomness_state);
    
    ;; Send claimable amount
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(sender_address)
        .store_coins(claimable)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x636c61696d, 40)  ;; "claim" response
        .store_coins(claimable)
        .store_coins(vested_amount)
        .end_cell();
    
    send_raw_message(msg, 64);
}

() handle_reroll_bonus(slice in_msg_body, slice sender_address) impure {
    ;; Load contract state
    (cell config_cell, cell collection_config, cell tax_states, 
     cell bonus_states, cell vesting_states, cell randomness_state) = load_data();
    
    slice config = config_cell.begin_parse();
    config~skip_bits(267 * 5);  ;; Skip addresses
    cell prices_cell = config~load_ref();
    int paused = config~load_uint(1);
    
    ;; Check if protocol is paused
    throw_if(error::protocol_paused, paused);
    
    ;; Parse reroll parameters
    slice nft_mint = in_msg_body~load_msg_addr();
    
    ;; Load bonus state
    int nft_hash = slice_hash(nft_mint);
    (slice bonus_data, int found) = bonus_states.udict_get?(256, nft_hash);
    throw_unless(error::no_nft, found);
    
    bonus_data~skip_bits(267);  ;; Skip mint
    int tier = bonus_data~load_uint(8);
    int old_bonus_bps = bonus_data~load_uint(16);
    bonus_data~skip_bits(64 * 2);  ;; Skip vesting times
    int claimed = bonus_data~load_uint(1);
    int fee_deducted = bonus_data~load_coins();
    
    ;; Get base price for tier
    slice prices = prices_cell.begin_parse();
    int base_price = 0;
    repeat(tier + 1) {
        base_price = prices~load_coins();
    }
    
    ;; Load user tax state
    int user_hash = slice_hash(sender_address);
    (slice user_tax_data, found) = tax_states.udict_get?(256, user_hash);
    
    int tax_rate_bps = INITIAL_TAX_BPS;
    if (found) {
        user_tax_data~skip_bits(267);  ;; Skip user address
        tax_rate_bps = user_tax_data~load_uint(16);
    }
    
    ;; Calculate tax amount
    int tax_amount = calculate_tax(base_price, tax_rate_bps);
    
    ;; Generate new random bonus
    (int min_bonus, int max_bonus) = get_tier_bonus_range(tier);
    int random_value = generate_random(sender_address, nft_mint, now());
    int new_bonus_bps = calculate_random_bonus(random_value, min_bonus, max_bonus);
    
    ;; Update bonus state
    cell new_bonus_data = begin_cell()
        .store_slice(nft_mint)
        .store_uint(tier, 8)
        .store_uint(new_bonus_bps, 16)
        .store_uint(now(), 64)  ;; new vesting_start
        .store_uint(VESTING_DURATION, 64)
        .store_uint(claimed, 1)
        .store_coins(fee_deducted + tax_amount)
        .end_cell();
    
    bonus_states~udict_set(256, nft_hash, new_bonus_data.begin_parse());
    
    ;; Update vesting state
    int new_vesting_amount = (base_price * new_bonus_bps) / 10000;
    
    cell new_vesting_data = begin_cell()
        .store_slice(nft_mint)
        .store_coins(new_vesting_amount)
        .store_coins(0)  ;; reset released_amount
        .store_uint(now(), 64)  ;; start_timestamp
        .store_uint(now() + VESTING_DURATION, 64)  ;; end_timestamp
        .store_uint(now(), 64)  ;; last_claimed_timestamp
        .end_cell();
    
    vesting_states~udict_set(256, nft_hash, new_vesting_data.begin_parse());
    
    ;; Update user tax rate
    tax_rate_bps = min(tax_rate_bps + TAX_INCREMENT_BPS, TAX_CAP_BPS);
    
    cell new_tax_data = begin_cell()
        .store_slice(sender_address)
        .store_uint(tax_rate_bps, 16)
        .store_uint(now(), 64)
        .store_uint(1, 32)  ;; increment swap count
        .end_cell();
    
    tax_states~udict_set(256, user_hash, new_tax_data.begin_parse());
    
    ;; Save updated state
    save_data(config_cell, collection_config, tax_states, 
              bonus_states, vesting_states, randomness_state);
    
    ;; Send response
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(sender_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x7265726f6c6c, 48)  ;; "reroll" response
        .store_uint(old_bonus_bps, 16)
        .store_uint(new_bonus_bps, 16)
        .store_coins(tax_amount)
        .end_cell();
    
    send_raw_message(msg, 64);
}

;; ===============================================
;; Main Entry Point
;; ===============================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Accept simple transfers
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {  ;; Ignore bounced messages
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == op::initialize) {
        handle_initialize(in_msg_body, sender_address);
        return ();
    }
    
    if (op == op::swap_defai_for_nft) {
        handle_swap_defai_for_nft(in_msg_body, sender_address);
        return ();
    }
    
    if (op == op::redeem) {
        handle_redeem(in_msg_body, sender_address);
        return ();
    }
    
    if (op == op::claim_vested) {
        handle_claim_vested(in_msg_body, sender_address);
        return ();
    }
    
    if (op == op::reroll_bonus) {
        handle_reroll_bonus(in_msg_body, sender_address);
        return ();
    }
    
    throw(0xffff);  ;; Unknown operation
}

;; ===============================================
;; Get Methods
;; ===============================================

(slice, slice, slice, slice, slice, int, int) get_config() method_id {
    (cell config_cell, _, _, _, _, _) = load_data();
    slice config = config_cell.begin_parse();
    
    slice admin = config~load_msg_addr();
    slice old_mint = config~load_msg_addr();
    slice new_mint = config~load_msg_addr();
    slice collection = config~load_msg_addr();
    slice treasury = config~load_msg_addr();
    config~load_ref();  ;; Skip prices
    int paused = config~load_uint(1);
    int vrf_enabled = config~load_uint(1);
    
    return (admin, old_mint, new_mint, collection, treasury, paused, vrf_enabled);
}

(int, int, int, int, int) get_tier_prices() method_id {
    (cell config_cell, _, _, _, _, _) = load_data();
    slice config = config_cell.begin_parse();
    config~skip_bits(267 * 5);  ;; Skip addresses
    cell prices_cell = config~load_ref();
    slice prices = prices_cell.begin_parse();
    
    return (prices~load_coins(), prices~load_coins(), prices~load_coins(), 
            prices~load_coins(), prices~load_coins());
}

(int, int, int, int) get_user_tax_state(slice user_address) method_id {
    (_, _, cell tax_states, _, _, _) = load_data();
    
    int user_hash = slice_hash(user_address);
    (slice user_tax_data, int found) = tax_states.udict_get?(256, user_hash);
    
    if (~ found) {
        return (INITIAL_TAX_BPS, 0, 0, 0);
    }
    
    user_tax_data~skip_bits(267);  ;; Skip user address
    int tax_rate_bps = user_tax_data~load_uint(16);
    int last_swap_timestamp = user_tax_data~load_uint(64);
    int swap_count = user_tax_data~load_uint(32);
    
    ;; Check if tax should be reset
    if (now() - last_swap_timestamp >= TAX_RESET_DURATION) {
        tax_rate_bps = INITIAL_TAX_BPS;
        swap_count = 0;
    }
    
    return (tax_rate_bps, last_swap_timestamp, swap_count, 1);
}

(int, int, int, int, int, int) get_bonus_state(slice nft_mint) method_id {
    (_, _, _, cell bonus_states, _, _) = load_data();
    
    int nft_hash = slice_hash(nft_mint);
    (slice bonus_data, int found) = bonus_states.udict_get?(256, nft_hash);
    
    if (~ found) {
        return (0, 0, 0, 0, 0, 0);
    }
    
    bonus_data~skip_bits(267);  ;; Skip mint
    int tier = bonus_data~load_uint(8);
    int bonus_bps = bonus_data~load_uint(16);
    int vesting_start = bonus_data~load_uint(64);
    int vesting_duration = bonus_data~load_uint(64);
    int claimed = bonus_data~load_uint(1);
    int fee_deducted = bonus_data~load_coins();
    
    return (tier, bonus_bps, vesting_start, vesting_duration, claimed, fee_deducted);
}

(int, int, int, int, int, int) get_vesting_state(slice nft_mint) method_id {
    (_, _, _, _, cell vesting_states, _) = load_data();
    
    int nft_hash = slice_hash(nft_mint);
    (slice vesting_data, int found) = vesting_states.udict_get?(256, nft_hash);
    
    if (~ found) {
        return (0, 0, 0, 0, 0, 0);
    }
    
    vesting_data~skip_bits(267);  ;; Skip mint
    int total_amount = vesting_data~load_coins();
    int released_amount = vesting_data~load_coins();
    int start_timestamp = vesting_data~load_uint(64);
    int end_timestamp = vesting_data~load_uint(64);
    int last_claimed = vesting_data~load_uint(64);
    
    ;; Calculate current vested amount
    int vested_amount = calculate_vested_amount(total_amount, start_timestamp, 
                                               end_timestamp, now());
    
    return (total_amount, released_amount, vested_amount, 
            start_timestamp, end_timestamp, last_claimed);
}

int get_is_paused() method_id {
    (cell config_cell, _, _, _, _, _) = load_data();
    slice config = config_cell.begin_parse();
    config~skip_bits(267 * 5);  ;; Skip addresses
    config~load_ref();  ;; Skip prices
    return config~load_uint(1);
}

int seqno() method_id {
    return 0;
}