;; DefAI RWA (Real World Assets) Contract for TON
;; Handles RWA registration, validation, and management

#include "stdlib.fc";

;; Constants  
const int RWA_REGISTRATION_FEE = 10000000; ;; 0.01 TON
const int MAX_RWA_PER_ESTATE = 100;
const int MAX_METADATA_SIZE = 1024; ;; bytes
const int MIN_RWA_VALUE = 1000000; ;; 0.001 TON minimum value
const int RWA_VERIFICATION_PERIOD = 259200; ;; 72 hours

;; Operation codes
const int op::register_rwa = 0x3001;
const int op::verify_rwa = 0x3002;
const int op::update_rwa_value = 0x3003;
const int op::transfer_rwa = 0x3004;
const int op::remove_rwa = 0x3005;
const int op::claim_rwa = 0x3006;
const int op::update_metadata = 0x3007;
const int op::batch_register = 0x3008;
const int op::get_rwa_info = 0x3009;
const int op::validate_ownership = 0x300a;

;; RWA Types
const int RWA_REAL_ESTATE = 1;
const int RWA_VEHICLE = 2;
const int RWA_COLLECTIBLE = 3;
const int RWA_FINANCIAL = 4;
const int RWA_INTELLECTUAL = 5;
const int RWA_OTHER = 6;

;; RWA Status
const int STATUS_PENDING = 0;
const int STATUS_VERIFIED = 1;
const int STATUS_DISPUTED = 2;
const int STATUS_TRANSFERRED = 3;
const int STATUS_CLAIMED = 4;

;; Error codes
const int error::unauthorized = 601;
const int error::rwa_not_found = 602;
const int error::invalid_value = 603;
const int error::max_rwa_exceeded = 604;
const int error::already_verified = 605;
const int error::not_verified = 606;
const int error::invalid_metadata = 607;
const int error::verification_expired = 608;
const int error::already_claimed = 609;
const int error::invalid_rwa_type = 610;
const int error::insufficient_fee = 611;

;; Storage layout
;; rwa_registry: dict<rwa_id, [estate_id, owner, rwa_type, value, status, created_at, verified_at, metadata_hash]>
;; estate_rwas: dict<estate_id, dict<rwa_id, bool>>
;; rwa_counter: int
;; verifier: address
;; treasury: address
;; total_value_locked: int

;; Load RWA registry data
(cell, cell, int, slice, slice, int) load_rwa_data() inline {
    var ds = get_data().begin_parse();
    var rwa_registry = ds~load_dict();
    var estate_rwas = ds~load_dict();
    var rwa_counter = ds~load_uint(64);
    var verifier = ds~load_msg_addr();
    var treasury = ds~load_msg_addr();
    var total_value_locked = ds~load_coins();
    return (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Save RWA data
() save_rwa_data(cell rwa_registry, cell estate_rwas, int rwa_counter,
                 slice verifier, slice treasury, int total_value_locked) impure {
    set_data(begin_cell()
        .store_dict(rwa_registry)
        .store_dict(estate_rwas)
        .store_uint(rwa_counter, 64)
        .store_slice(verifier)
        .store_slice(treasury)
        .store_coins(total_value_locked)
        .end_cell());
}

;; Register new RWA
() register_rwa(slice owner, int estate_id, int rwa_type, int value,
                int metadata_hash, int registration_fee) impure {
    throw_unless(error::invalid_rwa_type, 
        (rwa_type >= RWA_REAL_ESTATE) & (rwa_type <= RWA_OTHER));
    throw_unless(error::invalid_value, value >= MIN_RWA_VALUE);
    throw_unless(error::insufficient_fee, registration_fee >= RWA_REGISTRATION_FEE);
    
    var (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked) = load_rwa_data();
    
    ;; Check estate RWA count
    var (estate_dict, found) = estate_rwas.udict_get?(256, estate_id);
    var rwa_count = 0;
    if (found) {
        var key = -1;
        do {
            (key, _, found) = estate_dict~udict_get_next?(64, key);
            if (found) {
                rwa_count += 1;
            }
        } until (~ found);
    } else {
        estate_dict = new_dict();
    }
    
    throw_unless(error::max_rwa_exceeded, rwa_count < MAX_RWA_PER_ESTATE);
    
    ;; Create RWA entry
    var rwa_id = rwa_counter;
    var rwa_data = begin_cell()
        .store_uint(estate_id, 256)
        .store_slice(owner)
        .store_uint(rwa_type, 8)
        .store_coins(value)
        .store_uint(STATUS_PENDING, 8)
        .store_uint(now(), 64)
        .store_uint(0, 64) ;; verified_at (not verified yet)
        .store_uint(metadata_hash, 256)
        .end_cell();
    
    ;; Add to registry
    rwa_registry~udict_set(64, rwa_id, rwa_data.begin_parse());
    
    ;; Add to estate RWAs
    estate_dict~udict_set(64, rwa_id, 
                         begin_cell().store_uint(1, 1).end_cell().begin_parse());
    estate_rwas~udict_set(256, estate_id, estate_dict);
    
    ;; Send registration fee to treasury
    if (registration_fee > 0) {
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(treasury)
            .store_coins(registration_fee)
            .store_uint(0, 107)
            .end_cell();
        send_raw_message(msg, 1);
    }
    
    rwa_counter += 1;
    save_rwa_data(rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Verify RWA (only by authorized verifier)
() verify_rwa(slice sender, int rwa_id) impure {
    var (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked) = load_rwa_data();
    
    throw_unless(error::unauthorized, equal_slices(sender, verifier));
    
    ;; Get RWA data
    var (rwa_slice, found) = rwa_registry.udict_get?(64, rwa_id);
    throw_unless(error::rwa_not_found, found);
    
    var rs = rwa_slice;
    var estate_id = rs~load_uint(256);
    var owner = rs~load_msg_addr();
    var rwa_type = rs~load_uint(8);
    var value = rs~load_coins();
    var status = rs~load_uint(8);
    var created_at = rs~load_uint(64);
    var verified_at = rs~load_uint(64);
    var metadata_hash = rs~load_uint(256);
    
    throw_unless(error::already_verified, status == STATUS_PENDING);
    throw_unless(error::verification_expired, 
        now() <= created_at + RWA_VERIFICATION_PERIOD);
    
    ;; Update status and verification time
    status = STATUS_VERIFIED;
    verified_at = now();
    total_value_locked += value;
    
    ;; Save updated RWA data
    var updated_rwa = begin_cell()
        .store_uint(estate_id, 256)
        .store_slice(owner)
        .store_uint(rwa_type, 8)
        .store_coins(value)
        .store_uint(status, 8)
        .store_uint(created_at, 64)
        .store_uint(verified_at, 64)
        .store_uint(metadata_hash, 256)
        .end_cell();
    
    rwa_registry~udict_set(64, rwa_id, updated_rwa.begin_parse());
    
    save_rwa_data(rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Update RWA value (only by owner or verifier)
() update_rwa_value(slice sender, int rwa_id, int new_value) impure {
    var (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked) = load_rwa_data();
    
    ;; Get RWA data
    var (rwa_slice, found) = rwa_registry.udict_get?(64, rwa_id);
    throw_unless(error::rwa_not_found, found);
    
    var rs = rwa_slice;
    var estate_id = rs~load_uint(256);
    var owner = rs~load_msg_addr();
    var rwa_type = rs~load_uint(8);
    var old_value = rs~load_coins();
    var status = rs~load_uint(8);
    var created_at = rs~load_uint(64);
    var verified_at = rs~load_uint(64);
    var metadata_hash = rs~load_uint(256);
    
    throw_unless(error::unauthorized, 
        equal_slices(sender, owner) | equal_slices(sender, verifier));
    throw_unless(error::not_verified, status == STATUS_VERIFIED);
    throw_unless(error::invalid_value, new_value >= MIN_RWA_VALUE);
    
    ;; Update total value locked
    total_value_locked = total_value_locked - old_value + new_value;
    
    ;; Save updated RWA data
    var updated_rwa = begin_cell()
        .store_uint(estate_id, 256)
        .store_slice(owner)
        .store_uint(rwa_type, 8)
        .store_coins(new_value)
        .store_uint(status, 8)
        .store_uint(created_at, 64)
        .store_uint(verified_at, 64)
        .store_uint(metadata_hash, 256)
        .end_cell();
    
    rwa_registry~udict_set(64, rwa_id, updated_rwa.begin_parse());
    
    save_rwa_data(rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Claim RWA (for beneficiaries after estate becomes claimable)
() claim_rwa(slice beneficiary, int rwa_id, int estate_claimable) impure {
    throw_unless(error::unauthorized, estate_claimable);
    
    var (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked) = load_rwa_data();
    
    ;; Get RWA data
    var (rwa_slice, found) = rwa_registry.udict_get?(64, rwa_id);
    throw_unless(error::rwa_not_found, found);
    
    var rs = rwa_slice;
    var estate_id = rs~load_uint(256);
    var owner = rs~load_msg_addr();
    var rwa_type = rs~load_uint(8);
    var value = rs~load_coins();
    var status = rs~load_uint(8);
    var created_at = rs~load_uint(64);
    var verified_at = rs~load_uint(64);
    var metadata_hash = rs~load_uint(256);
    
    throw_unless(error::not_verified, status == STATUS_VERIFIED);
    throw_if(error::already_claimed, status == STATUS_CLAIMED);
    
    ;; Update status to claimed
    status = STATUS_CLAIMED;
    
    ;; Save updated RWA data
    var updated_rwa = begin_cell()
        .store_uint(estate_id, 256)
        .store_slice(beneficiary) ;; New owner is the beneficiary
        .store_uint(rwa_type, 8)
        .store_coins(value)
        .store_uint(status, 8)
        .store_uint(created_at, 64)
        .store_uint(verified_at, 64)
        .store_uint(metadata_hash, 256)
        .end_cell();
    
    rwa_registry~udict_set(64, rwa_id, updated_rwa.begin_parse());
    
    save_rwa_data(rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Batch register multiple RWAs
() batch_register_rwas(slice owner, int estate_id, cell rwa_list, int total_fee) impure {
    var (rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked) = load_rwa_data();
    
    var cs = rwa_list.begin_parse();
    var count = cs~load_uint(8);
    
    throw_unless(error::insufficient_fee, total_fee >= count * RWA_REGISTRATION_FEE);
    
    ;; Get or create estate RWA dict
    var (estate_dict, found) = estate_rwas.udict_get?(256, estate_id);
    if (~ found) {
        estate_dict = new_dict();
    }
    
    var i = 0;
    while (i < count) {
        var rwa_type = cs~load_uint(8);
        var value = cs~load_coins();
        var metadata_hash = cs~load_uint(256);
        
        ;; Create RWA entry
        var rwa_id = rwa_counter + i;
        var rwa_data = begin_cell()
            .store_uint(estate_id, 256)
            .store_slice(owner)
            .store_uint(rwa_type, 8)
            .store_coins(value)
            .store_uint(STATUS_PENDING, 8)
            .store_uint(now(), 64)
            .store_uint(0, 64)
            .store_uint(metadata_hash, 256)
            .end_cell();
        
        rwa_registry~udict_set(64, rwa_id, rwa_data.begin_parse());
        estate_dict~udict_set(64, rwa_id,
                             begin_cell().store_uint(1, 1).end_cell().begin_parse());
        
        i += 1;
    }
    
    estate_rwas~udict_set(256, estate_id, estate_dict);
    rwa_counter += count;
    
    ;; Send fees to treasury
    if (total_fee > 0) {
        var msg = begin_cell()
            .store_uint(0x10, 6)
            .store_slice(treasury)
            .store_coins(total_fee)
            .store_uint(0, 107)
            .end_cell();
        send_raw_message(msg, 1);
    }
    
    save_rwa_data(rwa_registry, estate_rwas, rwa_counter, verifier, treasury, total_value_locked);
}

;; Main message handler
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    var cs = in_msg_full.begin_parse();
    var flags = cs~load_uint(4);
    
    if (flags & 1) {
        return ();
    }
    
    var sender = cs~load_msg_addr();
    var op = in_msg_body~load_uint(32);
    var query_id = in_msg_body~load_uint(64);
    
    if (op == op::register_rwa) {
        var estate_id = in_msg_body~load_uint(256);
        var rwa_type = in_msg_body~load_uint(8);
        var value = in_msg_body~load_coins();
        var metadata_hash = in_msg_body~load_uint(256);
        register_rwa(sender, estate_id, rwa_type, value, metadata_hash, msg_value);
    }
    elseif (op == op::verify_rwa) {
        var rwa_id = in_msg_body~load_uint(64);
        verify_rwa(sender, rwa_id);
    }
    elseif (op == op::update_rwa_value) {
        var rwa_id = in_msg_body~load_uint(64);
        var new_value = in_msg_body~load_coins();
        update_rwa_value(sender, rwa_id, new_value);
    }
    elseif (op == op::claim_rwa) {
        var rwa_id = in_msg_body~load_uint(64);
        var estate_claimable = in_msg_body~load_uint(1);
        claim_rwa(sender, rwa_id, estate_claimable);
    }
    elseif (op == op::batch_register) {
        var estate_id = in_msg_body~load_uint(256);
        var rwa_list = in_msg_body~load_ref();
        batch_register_rwas(sender, estate_id, rwa_list, msg_value);
    }
}

;; Get methods
(int, int, slice, int, int, int) get_rwa_info(int rwa_id) method_id {
    var (rwa_registry, _, _, _, _, _) = load_rwa_data();
    
    var (rwa_slice, found) = rwa_registry.udict_get?(64, rwa_id);
    throw_unless(error::rwa_not_found, found);
    
    var rs = rwa_slice;
    var estate_id = rs~load_uint(256);
    var owner = rs~load_msg_addr();
    var rwa_type = rs~load_uint(8);
    var value = rs~load_coins();
    var status = rs~load_uint(8);
    
    return (estate_id, rwa_type, owner, value, status, found);
}

(int, int) get_registry_stats() method_id {
    var (_, _, rwa_counter, _, _, total_value_locked) = load_rwa_data();
    return (rwa_counter, total_value_locked);
}

(cell) get_estate_rwas(int estate_id) method_id {
    var (_, estate_rwas, _, _, _, _) = load_rwa_data();
    var (estate_dict, found) = estate_rwas.udict_get?(256, estate_id);
    if (found) {
        return estate_dict;
    } else {
        return new_dict();
    }
}